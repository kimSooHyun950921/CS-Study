# IPC/CPU/ CPU 스케줄링

### 0) **커널이란?**

    운영체제의 핵심 부분으로 파일 입출력, 프로세스 관리 등과 같이 운영체제의 기능을 담당한다.

### 0-1) **IPC (Inter-Process-Communication) 는** **무엇이고** **IPC 설비** **종류에는** **어떤** **것들이** **있나요?**

    IPC 통신은 프로세스 간의 통신을 가능하게 해주는 것이다.

    ** IPC 설비 종류 **

        익명 PIPE 

            -통신할 프로세스를 명확히 알 수 있는 경우에 사용 (ex. 부모-자식 간 통신) 
            -한쪽 방향으로만 통신이 가능한 반이중 통신 / 전이중 통신을 위해서 2개의 파이프가 필요
    

        Named PIPE (FIFO)

            -전혀 모르는 상태의 프로세스들 사이 통신에 사용 
            -부모 프로세스와 무관한 다른 프로세스도 통신 가능 
            - 읽기. 쓰기 동시에 불가능 / 전이중 통신 위해서 2개 필요


         Message Queue
         
           -Named pipe 와 입출력 방식 동일 
           -데이터의 흐름인 pipe 와 달리, 메모리 공간 
           -사용할 데이터에 번호 붙이며 여러 프로세스가 쉽게 동시에 데이터를 다룰 수 있음


        공유 메모리
        
           -데이터 자체를 공유하도록 지원하는 설비 
           -프로세스 간 메모리 영역 공유해서 사용할 수 있도록 허용 
           - 중개자 없이 곧바로 메모리에 접근할 수 있어 IPC 중 가장 빠르게 작동


         메모리 맵 
           -열린 파일을 메모리에 맵핑시켜 공유하는 방식 
           -주로 파일로 대용량 데이터를 공유해야 할 때 사용


        소켓 
           -클라이언트와 서버가 통신하는 구조로 원격에서 프로세스 간 데이터 공유할 때 사용


---

### 1) **스케줄링** **(Process scheduling) 이란?**

    여러 프로세스가 있고, 이 프로세스들이 자원(CPU 등)을 동시에 요구하는데 자원이 제한되어 있다. 
    그러면 제한된 자원들을 어떻게(순서를 할당하는 등) 나눠줄 것인지에 대한 정책을 말한다. 

### 1-1) **장기** **스케줄러와** **단기** **스케줄러의** **차이점은?**

        장기 스케줄러 
         - 메모리와 디스크 사이의 스케줄링 담당
         -어떤 프로세스에 각종 리소스 할당할 지 결정 
         - 실행 중인 프로세스의 수 제어 
         - 프로세스 상태: new -> ready


        단기 스케줄러 
        - cpu 와 메모리 사이의 스케줄을 담당
        -ready queue에 있는 프로세스 중 어떤 프로세스를 running 시킬지 결정
        - 프로세스에 cpu를 할당 
        - 프로세스 상태: ready -> running -> waiting -> ready 

---

### **2)  CPU 스케줄링** **이란?** 

    CPU 하나는 동시에 여러 개의 프로세스를 처리할 수 없기 때문에, 한 순간에 어떤 프로세스가 CPU를 사용할 수 있게 하는지 결정하는 정책으로 비선점형, 선점형으로 크게 나뉘어진다.

    선점형 

    OS가 CPU 사용권을 선점할 수 있는 경우 강제 회수 
    -장점: 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용 
    -단점: 우선순위가 높은 프로세스가 생길 때마다 계속 문맥 교환이 일어나므로 오버헤드가 큼


    비선점형
    
    프로세스 종료 혹은 I/O 이벤트가 있을 때까지 실행 보장 
    -장점: 프로세스 응답 시간을 예측하기 쉬움 
    -단점: 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생할 수 있음


### **2-1)  FCFS (First Come First Served) 스케줄링에** **대해** **설명하세요** 

        -비선점형 스케줄링으로 대기 큐에 도착한 순서대로 CPU를 할당한다.

        -소요 시간이 긴 프로세스가 먼저 도달하면 convoy effect가 발생하고  평균 대기 시간이 길어진다.


### **2-2)  SJF (Shortest Job First) 스케줄링에** **대해** **설명하세요** 

        -비선형 스케줄링으로 수행시간이 짧다고 판단되는 프로세스부터 먼저 CPU를 할당한다. 

        -FCFS보다 평균 대기 시간이 짧지만, 큰 작업에 대해서는 FCFS 보다 대기 시간 예측이 어렵다. 
        사용시간이 긴 프로세스는 영원히 CPU 를 할당 받지 못하는 starvation 현상이 발생할 수 있다.


### **2-3)  SRTF (Shortest Remaining Time First) 스케줄링에** **대해** **설명하세요**

 
        -선점형 스케줄링으로 처리가 가장 빠르게 이뤄진다고 판단하는 프로세스 먼저 수행한다. 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.

        -현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.


### **2-4)  Priority Scheduling 스케줄링에** **대해** **설명하세요** 

        -선점형 스케줄링으로 우선 순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다.

        -Aging 기법을 사용해 기다리는 시간이 길어질 경우 우선순위를 높여 CPU를 할당 받을 수 있게 한다.


### **2-5)  Round Robin 스케줄링에** **대해** **설명하세요** 

        -선점형 스케줄링으로 FCFS 알고리즘을 변형한 기법이다. 동일한 Time Quantum 만큼 프로세스를 할당받는다.

        -할당 시간이 크면 FCFS 와 같게 되고 작으면 문맥교환 (context switching)이 잦아져서 오버헤드가 증가한다.

### **2-6) 자신있는 스케줄링을 골라 그림으로 설명해주세여** (21/11/18 추가)



# 3. 인터럽트, 시스템콜, PCB와 Context Switching

### 1)인터럽트의 정의를 설명해 주세요.

```    프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 
    발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 것
```
### 2)외부/내부/소프트웨어 인터럽트에 대해 설명해주세요. 
```
    외부/내부 인터럽트는 `CPU의 하드웨어 신호에 의해 발생`
    
    소프트웨어 인터럽트는 `명령어의 수행에 의해 발생`
    
    외부 인터럽트는 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생한다. 
    
    내부 인터럽트는 0으로 나누기가 발생, 오버플로우, 명령어를 잘못 사용한 경우 (Exception)등에 발생 될 수 있다. 
    
    소프트웨어 인터럽트는 프로그램 처리 중 명령의 요청에 의해 발생한 것이다. 예를 들면 사용자가 프로그램을 실행시킬 때 발생한다. 
```    
### 3)인터럽트 발생 처리 과정에 대해서 설명해주세요. 
```
    1) 인터럽트 요청 신호 발생
    2) 프로그램 실행 중단
    3) 현재 프로그램 상태 보존 (복귀 주소를 stack에 저장)
    4) 인터럽트 처리 루틴 실행(문제가 어떤 것인지 파악)
    5) 인터럽트 서비스 루틴 실행(문제 해결)
    6) 상태 복구가 중단된 프로그램 재실행
```    
   ### 4)폴링과 인터럽트를 설명하고, 인터럽트를 필수적으로 사용하는 상황에 대해서 설명해주세요.  

  ```  폴링 방식- 
    
    사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
    
    인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. 
    (하드웨어에 비해 속도 느림)
    
    인터럽트 방식 -
    
    MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
    
    - Daisy Chain
    - 병렬 우선순위 부여
    
    실시간으로 대응이 필요한 경우에는 인터럽트 방식이 필수적이다. 
```
### 5)fork()에 동작 방식에 대해서 설명해주세요. 

```    
   새로운  프로세스를 생성할때 사용된다. 
    fork()를 실행 하는 순간 프로세스가 하나 더 생긴다. 
    이때 생긴 프로세스는 fork를 만들 프로세스와 동일한 복사본이다. 
    이때 OS는 위와 똑같은 2개의 프로그램이 동작한다고 생각하고, 
    fork()가 return 될 차례라고 생각한다. 
    Parent의 fork()값은 child의 pid 값이고, 
    Child의 fork()값은 0 이다. 
    그러나! Scheduler가 부모를 먼저 수행할지 아닐지 확신할 수 없다.
```
### 6)wait()에 동작 방식에 대해서 설명해주세요. 
```
    wait를 통해서, child의 실행이 끝날 때까지 기다려줌.
    parent가 먼저 실행되더라도, wait ()는 child가 끝나기 전에는 return하지 않으므로, 
    반드시 child가 먼저 실행된다. 
```
### 7)exec()에 동작 방식에 대해서 설명해주세요.
``` 
    child에서는 parent와 다른 동작을 하고 싶을 때는 exec를 사용할 수 있음.
```
### 8)Process Metadata의 종류를 말해주세요. 
```
    Process ID, Process State, Process Priority, CPU Registers, Owner, CPU Usage, Memeory Usage
```
### 9)PCB(Process Control Block)가 무엇이며, 왜 필요하고, 어떻게 관리 되나요?
```
    프로세스 메타데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김
    
    앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것이다. 
    
    Linked List 방식으로 관리된다. 삽입 삭제가 용이하다.
```
### 10) Context Switching의 의미와 언제 발생 하는지 설명해주세요. 
```
    CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정
    
    보통 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우에 Context Switching이 발생한다.
```
### 10) 트랩과 인터럽트의 차이점은 무엇일까요?
```
- 둘다 인터럽트는 맞음
- 트랩은 소프트웨어적 인터럽트, 인터럽트는 하드웨어적(I/O 디바이스) 인터럽트를 말함
```

## [페이징과 세그멘테이션, 페이지 교체 알고리즘]

### 11)내부 단편화와 외부 단편화에 대해 설명해주세요
```
    내부 단편화- 프레임보다 페이징이 작아서 메모리가 남고, 그 남은 부분을 사용하지 않음. 
    
    외부 단편화- 프레임 길이 만큼 동적으로 할당. 결국 너무 조각이 작아져 오버헤드가 커질수 있다. 
```
### 12)페이징과 세그멘테이션의 차이는?

```    페이징- 고정적인 길이의 프로세스 조각 
    
    세그멘테이션- 동적으로 크기에 맞춰 할당된 프로세스 조각
```
### 13)페이징 알고리즘에 대해 알고 있는데로 설명해주세요. 
```
    FIFO- first in first out, 메모리에 먼저 올라와 있는 페이지를 내보내는 알고리즘, 초기화 코드에 적당함.
    
    OPT- optimal 알고리즘, 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄. 
    
    LRU- Least recently Used, 최근에 사용되지 않은 페이지를 가장 먼저 내려보내는 알고리즘.
```  

### 14) 각각의 페이징 알고리즘은 어떻게 구현될까요? (1118 업데이트)
```
- LRU: doubly Linked List
- OPT: Priority Queue
- FIFO: Linked List 
```

### 페이징과 세그먼테이션의 장단점은?
```
페이징: 내부단편화가 생길 수 있음, 외부단편화는 없음
세그먼테이션: 외부단편화가 생길 수 있음, 내부단편화는 없음
```

### 15) 가상 메모리는 어떤건가요? 또 어떻게 구현되어 있나요?
```
가상 메모리는 부족한 물리 메모리를 보완하는 메모리로 보조기억장치를 이용해 구현합니다
```

### 16) 가상 메모리를 더 빠르게 구현 할 수 없나요?
```
캐시를 이용하면 더 빠르게 동작 할 수 있습니다
```

### 17) 이렇게 가상 메모리를 관리하는 주체는 어떤건가요?
```
운영체제가 이러한 것을 관리합니다
```

### 18) 컨텍스트 스위칭 시 캐시는 어떻게 처리 되나요?
```
이때 캐시는 초기화 됩니다
```

# 데드락 & 경쟁상태 & 세마포어와 뮤텍스
### 1) 멀티프로세싱이나 멀티스레드 환경에서 에서 생길 수 있는 문제점은 무엇일까요? 
```
1. 경쟁상태가 발생 할 수 있음(자원이 다르게 변경될 수 있음) - 자원공유에대한 문제
2. 데드락: 프로세스들이 자원을 할당받지못해 실행되지 못하는 상태
```

### 2) 데드락이 뭔지 설명해주세요
```
프로세스나 스레드가 서로 자원을 가지고 놓지 않아 다음상태로 전이되지 못하는 상태
```

```c
/* thread one runs in this function */
    public void *do work one(void *param){
        pthread mutex lock(&first mutex);
        pthread mutex lock(&second mutex);
        /**
        * Do some work
        */
        pthread mutex unlock(&second mutex);
        pthread mutex unlock(&first mutex);
        pthread exit(0);
        }
        /* thread two runs in this function */
        void *do work two(void *param)
        {
        pthread mutex lock(&second mutex);
        pthread mutex lock(&first mutex);
        /**
        * Do some work
        */
        pthread mutex unlock(&first mutex);
        pthread mutex unlock(&second mutex);
        pthread exit(0);
    }
```
### 3) 데드락이 왜발생하나요?
    ```
    - 아래 4가지 상황이 동시다발적으로 생성되면 발생할 수 있음
    1. 상호배제: 하나의자원은 한번에 하나의 프로세스 혹은스레드가 쓸 수 있을때
    2. Hold & Wait: 스레드가 하나의 자원을 붙잡고있는 상태에서 다른 자원을 얻으려고 하는 상태
    3. 비선점: 자원은 프로세스자체가 자발적으로 놓아주어야 하는경우(선점되지 않고)
    4. 순환 기다림: T0는 T1의 자원을 기다리고 있고 T1은 T2의 자원을 기다리는 형태로 순환적으로 프로세스가 각자원을 기다리는 경우

    ```

### 4) 데드락을 예방할수 있는 방법이 있을까요?
    ```
    1. 안전상태
    - 데드락이발생되지 않는 안전한 프로세스 실행 순서만들기
    2. 자원 할당 그래프알고리즘
    3. 은행원 알고리즘
        - 자원의 할당 여부를 결정하기 전에 미리 결정된 자원의 최대가능한 할당량을 시뮬레이션하여 안정상태의 여부를 검사한다. 대기중인 모든 활동의 교착상태 가능성을 조사하여 "안정상태" 여부를 검사확인하는 방법."
        출처: https://hoyeonkim795.github.io/posts/bankers/
    ```
    ```
    데드락을 다루는방법
    1. 데드락이 결고 발생하지 않는다고 가정하고 무시하기
        - 윈도우/리눅스같은 OS에서 사용됨
    2. 회피하거나 예방하는 프로토콜만들기
        - 커널개발자/애플리케이션 개발자들이 구현
        - 데드락회피방법:
            - 
        - 데드락 예방: 데드락 발생조건 4가지중 하나만 성립안하면됨
            - 상호배제: 공유가능하게 만든다(read-only), mutex-lock은 불가능
            - Hold&Wait: 다른 자원이 필요할때는 지금 가지고 있는자원을 해제하도록해야함
            기아상태를 가질수있고, 자원 유용성이 낮음
            - 비선점: 잡고있는자원을 암시적으로로 해제시킴
            - 순환대기: 임의의 자원을 요구하도록 함, 무조건 자기보다 작은 번호의 자원을 요구하도록함 
    3. 데드락 상태를 허락하고 탐지후 회복하는방법
        - 데이터베이스와같은 일부시스템에서 채택
    ```
### 5) 기아상태와 경쟁상태의 차이는 무엇을까요?
```
- 경쟁상태: 같은데이터를 동시에 조작하여 순서에따라 다른결과가 나오는 상태 (동기화되지 않음) - 자원공유할때 나오는문제
- 기아상태: 프로세스가 자원을 할당받지 못하는상태(프로세스 스케줄링)
```

### 6) 경쟁상태와 데드락의 차이는 무엇인가요?
```
경쟁상태는 공유하는자원을 서로다른 프로세스가 변경하는 문제이고,
데드락은 서로다른 프로세스가 자원을 할당받지 못하는 상태일때 상기는 문제이다.
```


### 7) 경쟁상태가 발생할 수 있는것을 실제 예제(프로그램언어등)에서 설명해주세요
```
텍스트파일을 변경하려고할때 같은내용을 하나는 2로, 하나로 3으로 변경하려하면 실행순서에따라 결과는 2가되기도 하고 3이되기도한다.
```
### 8) 경쟁상태를 예방할 수 있는 방법이 어떤것이 있나요?
```
세마포어와 뮤텍스, 모니터방법등이 있다.
```
### 9) 세마포어와 뮤텍스의 차이점은 무엇일까요?
```
1. semapore: 이진세마포어가 mutex처럼 사용된다. 동시에 사용한 프로세스숫자를 s로하고 숫자를 하나씩 줄여가면서 숫자가 0이되면 대기한다(wait) 프로세스가 완료되면 s를 하나씩 증가시킨다.
2. mutex: 단순히 critical section에 lock을 걸어 다른 프로세스가 진입하지 못하게하는것
```
### 10) 아래의 코드를 실행하면 count 값은 어떻게 나오나요? 
```java
class Counter {
int count=0;
Counter() {
    Thread thread1 = new Thread(new Runnable() {
    @Override
    public void run() {
        count();
    }      
    });
    Thread thread2 = new Thread(new Runnable() {
    @Override
    public void run() {
        count();
    }      
    });
    thread1.start();
    thread2.start();
}

void count() {
    for(int i=0; i<100000; i++) {
    count++;
    }
}
}
```


``` 
20000보다 작은 결과가 나온다.
```

### 11) 정상적으로 실행하려면 어떻게 바꿔야할까요?
```
count를 하는곳에  lock을 걸어야합니다.
자바 문법으로는 synchronized를 이용하거나, 스레드안전성 객체인 concurrent패키지를 이용하거나, immutable 객체로 만들면됩니다. 
```

# 프로세스와 스레드 / 프로세스 주소 공간

### 1-1) **스택 오버플로, 힙 오버플로에 대해 설명해주세요**
```
HEAP과 STACK영역은 같은 공간을 공유한다.
이 때, 각 영역에 너무 많은 할당이 발생하면 상대 공간을 침범하는 일이 발생할 수 있는데,
이를 HEAP OVERFLOW, STACK OVERFLOW라고 부른다.
```
### 1-2) **Data 영역과 Bss 영역을 구분하는 이유는 무엇인가요?**
```
프로그램의 불필요한 실행코드를 늘리지 않기 위해서이다.
초기화되는 Data 영역 변수는 그 값을 프로그램이 가지고 있어야 한다.
반면, Bss 영역 변수는 별도의 초기화 과정이 필요 없으므로 프로그램에 저장하지 않아도 된다.
따라서 이 두 영역을 구분함으로써 Bss 변수의 초기화 값을 저장하는 공간을 아낄 수 있다.
```
### 1-3) **임계 구역 문제를 해결하기 위한 요구 조건 3가지에 대해서 설명해주세요**
```
1. 상호 배제(mutual exclusion)는 하나의 프로세스가 임계 구역에서 실행되고 있다면,
    다른 프로세스는 임계 구역에서 실행될 수 없음을 의미한다.
2. 진행(process)은 임계 구역에 실행되고 있는 프로세스가 없으면, 
    들어갈 프로세스를 적절히 선택해줘야 함을 의미한다.
3. 한정된 대기(bounded waiting)는 프로세스의 기아를 방지하기 위해,
    한번 임계 구역에서 실행된 프로세스는 다음 실행에 대한 제한을 두어야 한다는 의미이다.
```

#  페이지 교체 알고리즘

### 1) **요구 페이지 기법에서, 수정이 되지 않는 페이지를 선택하고자 하는 이유에 대해 설명해주세요**
```
수정이 자주 발생하면, 메인 메모리에서 내보낼 때, 하드디스크에서 추가적인 수정을 진행하여야 하기 때문이다.
```

### 2) **OPT알고리즘이 거의 사용되지 않는 이유에 대해 설명해주세요**
```
가장 오랫동안 사용되지 않을 페이지를 희생양 페이지로 선택한다.
실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려운 알고리즘이다.
```

### 3) **victim page를 선정 방법 중, 더 효율적인 방법과 그 이유에 대해 설명해주세요**
```
victim page의 선정 기준은 Global과 Local이 있으며, 전체를 기준으로 교체하는 것이 더 효율적이다.
자기 프로세스 페이지에서만 교체를 하면, 교체를 해야할 때 각각 모두 교체를 진행해야 하기 때문이다.
```

#  메모리/파일시스템

### 1) **참조 지역성(Locality of reference)에 대해 설명해주세요**
```
프로그램은 실행 중 어느 한 특정 부분만 한동안 집중적으로 액세스하는 특성
```
### 1-1) **참조 지역성(Locality of reference)의 종류 3가지에 대해 설명해주세요**
```
공간 지역성 : 참조된 메모리 근처의 메모리를 참조.
시간 지역성 : 참조했던 메모리는 빠른 시간 내 다시 참조될 수 있음.
순차 지역성 : 데이터가 순차적으로 액세스 됨.
```

### 2) **캐싱(Caching)에 대해 설명해주세요**
```
캐시는 자주 사용될 자료의 복사본을 저장하는 빠른 메모리 영역이다.
캐시된 복사본을 사용하면, 원래 자료를 사용하는 것보다 더 빠르기에 효율적이다.
```

### 3) **Sequential Access vs. Random Access , SDD는 왜 빠를까요?**
```
Random Access(임의 접근)이란?
임의의 주소가 주어질 때 어떤 작업이든 똑같은 시간으로 접근이 가능하다는 의미를 갖는다. 무작위 접근이란 뜻이 아니다.
위치와 무관하게 직접 레코드에 접근할 수 있기 때문에 직접 접근이라는 용어로도 쓰인다.

HDD는 순차 접근 방식인 것에 반면, SSD는 임의 접근 방식을 사용한다. 
SSD는 HDD에 비해 탐색 시간 없이 데이터에 접근이 가능하므로 접근 시간이 빠르다.

HDD는 금속 디스크를 사용하지만, SSD는 메모리 반도체를 사용한다. 
따라서, HDD는 데이터를 디스크에 저장하는 반면, SSD는 반도체 소자에 저장하므로 SSD의 속도가 더 빠르다.
```
참고출처: https://ddb8036631.github.io/categories/question
