**DS**
[DB](https://gyoogle.dev/blog/computer-science/data-structure/Stack%20&%20Queue.html)

# [Array & ArrayList & LinkedList(지안)]

## 1)Array를 적용시키면 좋을 데이터의 예를 구체적으로 들어주세요. 구체적 예시와 함께 Array를 적용하면 좋은 이유, 그리고 Array를 사용하지 않으면 어떻게 되는지 함께 서술해주세요.

    Array를 적용시키면 좋은 예로 주식 차트가 있습니다. 
    
    주식 차트에 대한 데이터는 요소가 중간에 새롭게 추가되거나 삭제되는 정보가 아니며, 날짜별로 주식 가격이 차례대로 저장되어야 하는 데이터입니다. 

    즉, 순서가 굉장히 중요한 데이터 이므로 Array 같이 순서를 보존해주는 자료구조를 사용하는 것이 좋습니다. 

    이와 같은 데이터에 Array를 사용하지 않는 경우, 즉 순서가 없는 자료 구조를 사용하는 경우에는 날짜별 주식 가격을 확인하기 어려우며 매번 전체 자료를 읽어 들이고 비교해야 하는 번거로움이 발생합니다.


## 2)Array 와 Linked List 의 차이가 무엇인가요? (N사 전화면접 기출)

  `<Array>`

- Random Access를 지원
→ index 로 요소들을 빠르게 직접 접근할 수 있음
- 저장방식: 요소들은 인접한 메모리 위치에 연이어 저장
- 선언 시, 메모리가 컴파일 타임에 할당 (=정적 메모리 할당)
- stack 세션에 메모리 할당

- **시간복잡도**
    - 데이터 접근: O(1)
    - 데이터 삽입, 삭제: O(N)

---

`<Linked List>`

- Sequential Access를 지원
→ index 로 요소들을 빠르게 직접 접근할 수 있음
- 저장방식: 새로운 요소에 할당된 메모리 위치 주소가 linkedlist의 이전 요소에 저장
- 새로운 요소가 추가될 때 런타임에 메모리를 할당한다.( = 동적 메모리 할당)
- heap 세션에 메모리 할당

- **시간복잡도**
    - 데이터 접근: O(N)
    - 데이터 삽입, 삭제: O(N), 그러나 Array 보다 빠른 성능
    
   <br> 
→   삽입과 삭제가 빈번하게 일어난다면 LinkedList를 사용하는 것이 좋다. <br> 데이터에 접근하는 것이 빈번하게 일어난다면 Array를 사용하는 것이 좋다. 


## 3)Dynamic Array (ArrayList) 와 Linked List 의 차이에 대해 설명하세요

 `<Dynamic Array(ArrayList)>`
- 내부적으로 배열을 사용하여 데이터를 관리
- 인덱스를 가지고 있어 데이터 검색에 적합하고 속도가 빠름
- 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하므로 삽입, 삭제가 빈번할 경우 속도가 느리며 부적합
- 동기화를 지원하지 않아 Vector보다 빠르다.
    
 - **시간복잡도**
     - 데이터 접근: O(1)
     - 데이터 삽입, 삭제: O(N)

---

`<LinkedList>`
- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 됨
- 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 오래 걸리며 성능상 좋지 않음
- 데이터의 삽입, 삭제시 불필요한 데이터의 복사가 없어 데이터의 삽입, 삭제 시 유리

- **시간복잡도**
     - 데이터 접근: O(n)
     - 데이터 삽입, 삭제: O(1)
        
        하지만, 경우에 따라서 다르기도 하다.

        **Why?**  
            삽입, 삭제를 하기 위한 노드를 찾기 위해서는 결국 O(n)이 걸리고 삽입, 삭제를 위한 시간 복잡도까지 계산하면 결국 O(n)이 걸린다. <br>
            즉, 맨 앞과 뒤 요소의 삽입, 삭제만 한다면 O(1)이 걸림
            그러나 그렇지 않고, 중간 요소의 삽입, 삭제가 있으면 O(n).

<br>
→ 따라서 데이터의 검색이 주가 되는 경우에는 Dynamic Array(ArrayList)를 사용하는 게 좋다. <br>
데이터의 삽입, 삭제가 빈번하다면 Dynamic Array(ArrayList)보다는 LinkedList를 사용하는 편이 낫다.
    
<br>


# [Stack & Queue & Heap(예빈)]

## 1)Stack의 알고리즘과 스택 포인터를 설명하고 주로 언제 사용하는지 알려주세요.
    LIFO (Last In First Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나옴. 스택 포인터는 다음 값이 들어갈 위치를 가리키고 있음 (처음 기본값은 -1).함수의 콜스택, 문자열 역순 출력, 연산자 후위표기법


## 2)Queue의 동작 알고리즘과 어떻게 처음과 끝을 기억하는지 설명해주세요. 그리고 언제 주로 사용하나요?
    FIFO (First In First Out, 선입선출) : 가장 먼저 들어온 것이 가장 먼저 나옴. front와 rear pointer를 이용해서 처음과 끝을 기억한다. 버퍼, 마구 입력된 것을 처리하지 못하고 있는 상황, BFS. 

## 3)일반큐, 원형큐의 단점과 연결리스트 큐의 장점에 대해서 설명해주세요.  
    일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음
    원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한
    연결리스트 큐의 장점: 크기가 제한이 없고 삽입, 삭제가 편리

## 4)Heap에 대해서 아는만큼 설명해주세요. 
    언제 사용? 시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산
    힙 Time Complexity→ 삽입 : O(logn) , 삭제 : O(logn)
    힙이란? 완전 이진트리의 일종으로 반 정렬 상태이며 중복값을 허용하는 특징이 있다. 여러 값 중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조
    힙을 저장하는 표준적인 자료구조는 배열. 구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않음. 
    
    힙의 삭제-
    1. 최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제됨 (최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것)
    2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
    3. 힙을 재구성

    힙의 삽입-
    1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입
    2. 새로운 노드를 부모 노드들과 교환


# [ Tree & 이진 탐삭트리]
## 1) 아래와 같은 트리가 있을때 어떻게 트리를 순회할까요?
<img src='img/binary-tree-to-DLL.PNG'>

```
중위 순회: 8,4,9,2,10,5,11,1,6,13,3,14,7
후위 순회: 8 → 9 → 4 → 10 → 11 → 5 → 2 → 13 → 6 → 14 → 7 → 3 → 1
전위 순회:1 → 2 → 4 → 8 → 9 → 5 → 10 → 11 → 3 → 6 → 13 → 7 → 14
```
## 2) 이진 탐색트리의 목적은 무엇일까요?
```
효율적인 탐색능력과 
자료의 빠른 삽입 삭제를 위해 만들어짐
시간복잡도: O(logN)
```

## 3) 이잔탐색트리의 단점은 무엇이고, 이를 해결하려면 어떻게 해야할까요?
```
편향된 트리가 만들어질 수 있음
이를 개선해주려면 AVL 트리나 Red Balck 트리를 이용하면됨
```


# [트라이 & B Tree & B+Tree(태훈)]

## 1) 트라이에 대해 설명해 주세요
    트라이는 문자열을 빠르게 찾을 수 있는 트리 모양의 자료 구조입니다
    
## 2) B Tree와 B+Tree의 차이에 대해 설명 해 주세요
    두 가지 자료구조 모두 트리 형태를 띄고 있습니다
    하지만 B Tree는 모든 노드에 데이터와 키 값이 저장되어 있고,
    B+Tree에서는 리프 노드만이 데이터를 가지고 있습니다
    
## 3) 트라이 활용 사례에 대해 알려주세요
    트라이는 연관 검색어 기능 구현에 사용되기도 합니다
